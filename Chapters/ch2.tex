\chapter{Software Foundations}

\section{Overview}

In a Modular Robotic Platform (MRP), the software layer is responsible for transforming heterogeneous hardware and assemblies into a consistent and reusable programming model. The key challenge is maintaining portability and development velocity across different robots (ground, amphibious, aerial test rigs) and different electronics (breadboard prototypes vs. custom PCBs), while still enabling deterministic behavior where needed.

This thesis adopts a layered software strategy: (i) a toolchain and framework layer for portability and developer productivity, (ii) an ASCE abstraction layer that standardizes access to hardware assemblies and platform circuits, and (iii) a real-time execution model for concurrency and responsiveness on supported microcontrollers.

\section{Toolchain: C++ and PlatformIO}

All firmware is developed in C++ due to its balance between low-level control, performance, and support for reusable abstractions (classes, templates, modules). The project is built using PlatformIO as the development environment manager. PlatformIO provides a unified build system, dependency/library management, and multi-platform/multi-architecture workflows, which is aligned with the needs of an MRP that targets different boards over time \cite{platformio_docs,platformio_site,espressif_platformio}.

From an engineering perspective, the use of PlatformIO improves reproducibility and maintainability by making compiler settings, board targets, and dependencies explicit at the project level (e.g., via configuration files), rather than relying on IDE-specific state.

\section{Arduino Framework as a Portability Layer}

Firmware is based on the Arduino framework to benefit from its high-level API surface and portability across multiple microcontroller families. Arduino's programming model provides stable interfaces for common embedded operations such as GPIO, ADC, PWM, serial communication, and timing, enabling code reuse across boards with minimal changes \cite{arduino_docs}.

For ESP32-class platforms specifically, the Arduino core is implemented on top of Espressif's ESP-IDF stack, which provides access to vendor drivers and system services while preserving the Arduino programming experience \cite{arduino_esp32_docs,arduino_as_idf_component,arduino_esp32_repo}. This approach supports rapid iteration and cross-platform compatibility, while still allowing advanced features to be accessed when required.

\section{ASCE Framework Layer}

On top of Arduino, this thesis introduces ASCE's own framework as a reusable library layer. The goal of this layer is to formalize modularity in software by:

\begin{itemize}
	\item Abstracting platform circuits (e.g., ILITE, BULKER32, GillerS3, GillerDUO) behind stable interfaces.
	\item Encapsulating recurring hardware patterns (sensor buses, actuator drivers, input devices, screen rendering) into reusable components.
	\item Hiding platform-specific details (pin maps, voltage assumptions, peripheral quirks) behind configuration structures, pre-definitions, and well-scoped APIs.
\end{itemize}

This design enables developers to implement robot-specific behaviors while minimizing the need to manage low-level technicalities repeatedly. It also supports the MVP-to-MRP maturation path: early breadboard builds can share the same programming model as later PCB-based builds, with differences handled internally by platform definitions.

\section{Execution Model: FreeRTOS on ESP32 Platforms}

Several target platforms are based on ESP32-class microcontrollers, where FreeRTOS support is a natural fit. ESP-IDF includes a FreeRTOS-based execution environment, including implementations that support dual-core scheduling on compatible ESP targets \cite{espidf_freertos_overview,espidf_freertos_idf}.

Using FreeRTOS provides practical benefits for modular robotic systems:

\begin{itemize}
	\item \textbf{Concurrency:} decomposition of firmware into tasks (e.g., sensing, control, communication, UI).
	\item \textbf{Responsiveness:} preemptive scheduling with priorities, allowing time-sensitive tasks to run reliably \cite{freertos_sched}.
	\item \textbf{Structured communication:} queues, semaphores, and mutexes to coordinate subsystems safely \cite{freertos_queues,mastering_freertos}.
	\item \textbf{Scalability:} ability to add new modules as separate tasks without rewriting the entire control loop.
\end{itemize}

In the context of this thesis, FreeRTOS is used as an enabling mechanism for modular software composition. It supports separating robot behavior from low-level services (e.g., telemetry, user interface, communication framing), and it reduces coupling between subsystems.

\section{Open-Ended Integration Points for This Thesis}

The remainder of this thesis will ground the above foundations through concrete implementations, including:

\begin{itemize}
	\item Platform drivers (breadboard assemblies vs. PCB-based platforms) and their configuration strategy.
	\item Task partitioning and scheduling approach on ESP32-based platforms.
	\item Examples of ASCE APIs that expose stable ``contracts'' for sensors, actuators, and user interaction.
	\item Communication patterns and debugging facilities used across the platform family.
\end{itemize}

These examples will demonstrate how portability (Arduino + PlatformIO), modular abstraction (ASCE framework), and concurrency (FreeRTOS) jointly support the MRP goals of reuse, flexibility, and scalability.
